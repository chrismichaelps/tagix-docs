// Auto-generated by scripts/generate-api-docs.js
export interface ApiItem {
  name: string;
  kind: string;
  description: string;
}

export const API_DOCS: ApiItem[] = [
  {
    name: "StoreConfig",
    kind: "interface",
    description:
      "Configuration options for creating a TagixStore.\n@typeParam S - The state type, must have a `_tag` property for state identification.",
  },
  {
    name: "Action",
    kind: "interface",
    description:
      "Synchronous action definition.\n@typeParam TPayload - The payload type passed during dispatch.\n@typeParam TState - The state type this action operates on.",
  },
  {
    name: "AsyncAction",
    kind: "interface",
    description:
      "Asynchronous action with side effects.\n@typeParam TPayload - The payload type.\n@typeParam TState - The state type.\n@typeParam TError - The error type thrown by the effect.",
  },
  {
    name: "MiddlewareContext",
    kind: "interface",
    description:
      "Context object passed to middleware functions.\n@typeParam S - The store's state type.",
  },
  {
    name: "Middleware",
    kind: "type",
    description:
      "Middleware function that wraps action dispatch.\n@param context - Store context for reading state or dispatching nested actions.\n@returns A function that wraps the next middleware/handler.\n@remarks The returned function should return `true` (or void) to proceed with action execution, or `false` to block.",
  },
  {
    name: "SubscribeCallback",
    kind: "type",
    description: "Callback invoked on state changes. @param state - The new state.",
  },
  {
    name: "SubscribePathCallback",
    kind: "type",
    description:
      "Callback invoked when a specific path in state changes. @param value - The new value at the path.",
  },
  {
    name: "isAction",
    kind: "function",
    description:
      "Type guard to check if a value is a Tagix Action.\n@param value - Value to check.\n@returns True if value is an Action.",
  },
  {
    name: "isAsyncAction",
    kind: "function",
    description:
      "Type guard to check if a value is a Tagix AsyncAction.\n@param value - Value to check.\n@returns True if value is an AsyncAction.",
  },
  {
    name: "PayloadOf",
    kind: "type",
    description:
      "Extracts the payload type from an Action or ActionCreator.\n@typeParam T - The action or action creator type.",
  },
  {
    name: "StateOf",
    kind: "type",
    description:
      "Extracts the state type from an Action or ActionCreator.\n@typeParam T - The action or action creator type.",
  },
  {
    name: "DEFAULT_CONFIG",
    kind: "const",
    description:
      "Default configuration values for TagixStore.\n@remarks Used when no configuration is provided to `createStore`.",
  },
  {
    name: "ACTION_TYPE_PREFIX",
    kind: "const",
    description: "Prefix applied to all action types internally.",
  },
  {
    name: "ERROR_NAMES",
    kind: "const",
    description:
      "Error name constants for Tagix error types.\n@remarks Used internally for error identification and categorization.",
  },
  {
    name: "ErrorName",
    kind: "type",
    description: "Union type of all error names.",
  },
  {
    name: "ERROR_CODES",
    kind: "const",
    description:
      "Numeric error codes for each error type.\n@remarks Used for error categorization and analytics.",
  },
  {
    name: "ErrorCode",
    kind: "type",
    description: "Union type of all error codes.",
  },
  {
    name: "getErrorCode",
    kind: "const",
    description:
      "Maps an error name to its corresponding error code.\n@param name - The error name to look up.\n@returns The numeric error code.",
  },
  {
    name: "TagixErrorObject",
    kind: "interface",
    description:
      "Structured error object with tag, code, and message.\n@remarks All Tagix errors conform to this shape for consistent error handling.",
  },
  {
    name: "isTagixError",
    kind: "const",
    description:
      "Type guard to check if an error is a Tagix error.\n@param error - The value to check.\n@returns True if the error has the Tagix error structure.",
  },
  {
    name: "getErrorInfo",
    kind: "const",
    description:
      "Extracts structured error information from an unknown error.\n@param error - The error to extract information from.\n@returns TagixErrorObject if the error is a Tagix error, null otherwise.",
  },
  {
    name: "ERROR_CATEGORIES",
    kind: "const",
    description:
      "Error categories grouping related error codes.\n@remarks Used for error analytics and recovery strategies.",
  },
  {
    name: "ErrorCategory",
    kind: "type",
    description: "Union type of all error category names.",
  },
  {
    name: "getErrorCategory",
    kind: "const",
    description:
      "Gets the category for a given error code.\n@param code - The error code to look up.\n@returns The error category, or undefined if not found.",
  },
  {
    name: "isRecoverableError",
    kind: "const",
    description:
      "Checks if an error code represents a recoverable error.\n@param code - The error code to check.\n@returns True if the error is recoverable (STATE, ACTION, or PAYLOAD category).",
  },
  {
    name: "createErrorPayload",
    kind: "const",
    description:
      "Creates an error payload with the corresponding error code.\n@typeParam T - The payload object type.\n@param name - The error name.\n@param payload - The error payload data.\n@returns The payload with the error code added.",
  },
  {
    name: "StateTransitionError",
    kind: "const",
    description:
      "Thrown when a state transition produces an unexpected state tag in strict mode.\n@remarks Only thrown when `strict: true` is set in store configuration.",
  },
  {
    name: "MissingHandlerError",
    kind: "const",
    description: "Thrown when an action handler is not registered for a dispatched action.",
  },
  {
    name: "ActionNotFoundError",
    kind: "const",
    description: "Thrown when dispatching an action type that has not been registered.",
  },
  {
    name: "InvalidPayloadError",
    kind: "const",
    description:
      "Thrown when payload validation fails.\n@remarks Use `validatePayload` guard to trigger this error.",
  },
  {
    name: "NonExhaustiveMatchError",
    kind: "const",
    description:
      "Thrown when pattern matching is non-exhaustive.\n@remarks Use `exhaust` function to ensure all state tags are handled.",
  },
  {
    name: "RequiredPayloadError",
    kind: "const",
    description:
      "Thrown when a required payload is missing or null/undefined.\n@remarks Use `fromPayload` guard to trigger this error.",
  },
  {
    name: "PayloadValidationError",
    kind: "const",
    description:
      "Thrown when a payload validation predicate returns false.\n@remarks Use `validatePayload` guard to trigger this error.",
  },
  {
    name: "UnexpectedStateError",
    kind: "const",
    description:
      "Thrown when state is in an unexpected condition.\n@remarks Use `ensureState` guard to trigger this error when state tag doesn't match.",
  },
  {
    name: "TagixError",
    kind: "type",
    description:
      "Union type of all Tagix error instances.\n@remarks Use this for comprehensive error handling across the library.",
  },
  {
    name: "TagixStore",
    kind: "class",
    description:
      "Core store implementation for Tagix state management.\n@typeParam S - The state type, must be a discriminated union with `_tag` property.\n@remarks Manages state transitions, subscriptions, and error tracking.",
  },
  {
    name: "createStore",
    kind: "function",
    description:
      'Creates a new TagixStore instance.\n@param initialState - The starting state, must have a `_tag` property.\n@param stateConstructor - TaggedEnum constructor for state type safety.\n@param config - Optional store configuration.\n@returns A new TagixStore instance.\n@example\n```ts\nconst store = createStore(\n  CounterState.Value({ count: 0 }),\n  CounterState,\n  { name: "Counter" }\n);\n```',
  },
  {
    name: "RelaxedState",
    kind: "type",
    description:
      "Relaxed state type for action handlers that allows accessing any property.\nThe `& Record<string, any>` intersection allows accessing variant-specific properties\nwithout explicit type narrowing, while the base type ensures _tag is present.",
  },
  {
    name: "createAction",
    kind: "function",
    description:
      'Creates a synchronous action builder.\n@param type - Unique action identifier.\n@returns Action builder with chainable methods.\n@example\n```ts\nconst increment = createAction("Increment")\n  .withPayload({ amount: 1 })\n  .withState((s, p) => ({ count: s.count + p.amount }));\n```',
  },
  {
    name: "createAsyncAction",
    kind: "function",
    description:
      'Creates an asynchronous action builder with side effects.\n@typeParam TPayload - The payload type.\n@typeParam S - The state type.\n@typeParam TEffect - The effect result type.\n@param type - Unique action identifier.\n@returns Async action builder with chainable methods.\n@remarks Builder pattern: call `state`, `effect`, `onSuccess`, then `onError` to complete.\n@example\n```ts\nconst fetchUser = createAsyncAction<{ id: string }, UserState, User>("FetchUser")\n  .state(s => ({ ...s, loading: true }))\n  .effect(p => api.getUser(p.id))\n  .onSuccess((s, user) => ({ ...s, user, loading: false }))\n  .onError((s, err) => ({ ...s, error: err, loading: false }));\n```',
  },
  {
    name: "isStringPayload",
    kind: "const",
    description: "Type guard for string payloads.",
  },
  {
    name: "isNumberPayload",
    kind: "const",
    description: "Type guard for number payloads.",
  },
  {
    name: "isBooleanPayload",
    kind: "const",
    description: "Type guard for boolean payloads.",
  },
  {
    name: "isRecordPayload",
    kind: "const",
    description: "Type guard for record/object payloads.",
  },
  {
    name: "isArrayPayload",
    kind: "const",
    description: "Type guard for array payloads.",
  },
  {
    name: "isPlainObjectPayload",
    kind: "const",
    description: "Type guard for plain object payloads (not arrays, dates, etc.).",
  },
  {
    name: "notEmptyString",
    kind: "function",
    description:
      "Type guard for non-empty strings.\n@param value - The value to check.\n@returns True if value is a non-empty string.",
  },
  {
    name: "positiveNumber",
    kind: "function",
    description:
      "Type guard for positive numbers.\n@param value - The value to check.\n@returns True if value is a positive number.",
  },
  {
    name: "nonEmptyArray",
    kind: "function",
    description:
      "Type guard for non-empty arrays.\n@typeParam A - The array element type.\n@param value - The value to check.\n@returns True if value is a non-empty array.",
  },
  {
    name: "fromPayload",
    kind: "function",
    description:
      "Creates a function that extracts a required payload, throwing if missing.\n@typeParam P - The payload type.\n@returns A function that throws `RequiredPayloadError` if payload is null/undefined.",
  },
  {
    name: "validatePayload",
    kind: "function",
    description:
      "Creates a payload validator that throws if validation fails.\n@typeParam T - The payload type.\n@param predicate - The validation predicate.\n@param errorMessage - Optional custom error message.\n@returns A function that throws `PayloadValidationError` if predicate returns false.",
  },
  {
    name: "on",
    kind: "function",
    description:
      "Creates a function that executes only when state matches a specific tag.\n@typeParam T - The state type.\n@typeParam K - The state tag type.\n@param _tag - The state tag to match.\n@returns A function that returns undefined if tag doesn't match, otherwise executes the handler.",
  },
  {
    name: "when",
    kind: "function",
    description:
      "Creates a type guard that narrows state to a specific tag.\n@typeParam T - The state type.\n@typeParam K - The state tag type.\n@param _tag - The state tag to match.\n@returns A refinement function that narrows the state type.",
  },
  {
    name: "withState",
    kind: "function",
    description:
      "Executes a function with state if it matches the specified tag.\n@typeParam S - The state type.\n@typeParam K - The state tag type.\n@typeParam R - The return type.\n@param state - The state to check.\n@param tag - The state tag to match.\n@param fn - The function to execute if tag matches.\n@returns The function result, or undefined if tag doesn't match.",
  },
  {
    name: "ensureState",
    kind: "function",
    description:
      "Ensures store state matches a specific tag, throwing if it doesn't.\n@typeParam S - The state type.\n@typeParam K - The state tag type.\n@param store - The store instance.\n@param tag - The expected state tag.\n@returns The narrowed state.\n@throws {UnexpectedStateError} If state tag doesn't match.",
  },
  {
    name: "isInState",
    kind: "function",
    description:
      "Checks if store state has a specific tag.\n@typeParam S - The state type.\n@param store - The store instance.\n@param tag - The state tag to check for.\n@returns True if state tag matches.",
  },
  {
    name: "getTag",
    kind: "function",
    description:
      "Gets the tag from a state value.\n@typeParam S - The state type.\n@param state - The state value.\n@returns The state tag.",
  },
  {
    name: "hasTag",
    kind: "function",
    description:
      "Checks if a state value has a specific tag.\n@typeParam S - The state type.\n@param state - The state value.\n@param tag - The tag to check for.\n@returns True if state tag matches.",
  },
  {
    name: "matchState",
    kind: "function",
    description:
      "Pattern matches on state, executing the handler for the matching tag.\n@typeParam S - The state type.\n@typeParam R - The return type.\n@param state - The state to match on.\n@param cases - Object mapping state tags to handlers.\n@returns The handler result, or undefined if no handler exists for the tag.\n@remarks Non-exhaustive: missing tags return undefined.",
  },
  {
    name: "exhaust",
    kind: "function",
    description:
      "Exhaustive pattern matching on state, requiring handlers for all tags.\n@typeParam S - The state type.\n@typeParam R - The return type.\n@param state - The state to match on.\n@param cases - Object mapping all state tags to handlers.\n@returns The handler result for the matching tag.\n@throws {NonExhaustiveMatchError} If no handler exists for the state tag.\n@remarks Enforces compile-time exhaustiveness via type system.",
  },
  {
    name: "ContextId",
    kind: "type",
    description: "Unique identifier for context entries and subcontexts.",
  },
  {
    name: "ContextConfig",
    kind: "interface",
    description: "Configuration options for creating a TagixContext.",
  },
  {
    name: "TagixContext",
    kind: "class",
    description:
      "Context wrapper around TagixStore providing dependency injection, subcontexts, and hook patterns.\n@typeParam S - The state type, must be a discriminated union with `_tag` property.\n@remarks Manages subscriptions, child contexts, and provides dependency injection via `provide` method.",
  },
  {
    name: "createContext",
    kind: "function",
    description:
      "Creates a new TagixContext instance.\n@typeParam S - The state type, must be a discriminated union with `_tag` property.\n@param store - The TagixStore instance to wrap.\n@param config - Optional context configuration.\n@returns A new TagixContext instance.",
  },
  {
    name: "patch",
    kind: "function",
    description:
      "Creates an immutable patching function for objects.\n@typeParam T - The object type.\n@param base - The base object to patch.\n@returns A chainable patching function with a `value` property.\n@remarks Each call returns a new object, enabling immutable updates.\n@example\n```ts\nconst patcher = patch({ a: 1, b: 2 });\nconst result = patcher({ b: 3 })({ c: 4 }).value;\n// result = { a: 1, b: 3, c: 4 }\n```",
  },
  {
    name: "getState",
    kind: "function",
    description:
      "Gets state from a store if it matches the specified tag.\n@typeParam S - The state type.\n@typeParam K - The state tag type.\n@param store - The store instance.\n@param tag - The state tag to match.\n@returns Some(state) if tag matches, None otherwise.",
  },
  {
    name: "select",
    kind: "function",
    description:
      "Selects a property from an object.\n@typeParam T - The object type.\n@typeParam K - The property key type.\n@param obj - The object to select from.\n@param key - The property key.\n@returns The property value, or undefined if not present.",
  },
  {
    name: "pluck",
    kind: "function",
    description:
      'Creates a function that plucks a property (or nested property) from an object.\n@typeParam T - The object type.\n@typeParam K - The property path type (supports dot notation).\n@param key - The property key or dot-separated path (e.g., "user.name").\n@returns A function that extracts the value at the path.\n@remarks Returns undefined if any part of the path is null/undefined.',
  },
  {
    name: "combineSelectors",
    kind: "function",
    description:
      "Combines multiple selectors into a single selector returning a tuple.\n@typeParam T - The input state type.\n@typeParam R1 - The first selector return type.\n@typeParam R2 - The second selector return type.\n@param selector1 - First selector function.\n@param selector2 - Second selector function.\n@returns A selector that returns a tuple of results.\n@remarks Overloaded for 2 or 3 selectors.",
  },
  {
    name: "combineSelectors",
    kind: "function",
    description:
      "Combines three selectors into a single selector returning a tuple.\n@typeParam T - The input state type.\n@typeParam R1 - The first selector return type.\n@typeParam R2 - The second selector return type.\n@typeParam R3 - The third selector return type.\n@param selector1 - First selector function.\n@param selector2 - Second selector function.\n@param selector3 - Third selector function.\n@returns A selector that returns a tuple of three results.",
  },
  {
    name: "memoize",
    kind: "function",
    description:
      "Memoizes a selector function using reference equality.\n@typeParam T - The input type.\n@typeParam R - The return type.\n@param selector - The selector function to memoize.\n@returns A memoized version that returns cached result for same input reference.\n@remarks Uses `Object.is` for equality comparison. Cache invalidates on new input reference.",
  },
  {
    name: "getOrDefault",
    kind: "function",
    description:
      "Creates a function that returns a default value if input is undefined.\n@typeParam T - The value type.\n@param defaultValue - The default value to use.\n@returns A function that returns the input value or the default.",
  },
  {
    name: "createLoggerMiddleware",
    kind: "function",
    description:
      'Creates a middleware that logs actions and state changes to the console.\n@param options - Logger configuration options.\n@returns A middleware function.\n@remarks Supports collapsed groups, timestamps, duration tracking, and custom transformers.\n@example\n```ts\nconst logger = createLoggerMiddleware({\n  collapsed: true,\n  duration: true,\n  predicate: (action) => action.type.includes("User")\n});\n```',
  },
  {
    name: "getValue",
    kind: "function",
    description:
      'Safely gets a property value from a tagged union state.\nReturns the value if present, otherwise returns the default value.\n\n@typeParam S - The state type (tagged union).\n@typeParam K - The property key.\n@typeParam D - The default value type.\n@param state - The current state.\n@param key - The property key to access.\n@param defaultValue - The default value if property doesn\'t exist.\n@returns The property value or the default.\n\n@example\n```ts\n// In an action handler, safely access \'value\' which may not exist on all variants:\nconst increment = createAction<{ amount: number }, CounterState>("Increment")\n  .withPayload({ amount: 1 })\n  .withState((s, p) => ({\n    ...s,\n    value: getValue(s, "value", 0) + p.amount,\n  }));\n```',
  },
  {
    name: "getProperty",
    kind: "function",
    description:
      "Type-safe property accessor for tagged union states.\nReturns undefined if the property doesn't exist on the current variant.\n\n@typeParam S - The state type.\n@typeParam K - The property key.\n@param state - The current state.\n@param key - The property key to access.\n@returns The property value or undefined.",
  },
  {
    name: "updateState",
    kind: "function",
    description:
      'Creates a state updater that preserves variant-specific properties.\nUse this when updating properties that may not exist on all variants.\n\n@typeParam S - The state type.\n@param state - The current state.\n@param updates - Object with properties to update.\n@returns The updated state.\n\n@example\n```ts\nconst increment = createAction<{ amount: number }, CounterState>("Increment")\n  .withPayload({ amount: 1 })\n  .withState((s, p) => updateState(s, {\n    value: getValue(s, "value", 0) + p.amount\n  }));\n```',
  },
  {
    name: "asVariant",
    kind: "function",
    description:
      "Narrows the state to a specific variant if it matches the given tag.\nReturns undefined if the state is not the specified variant.\n\n@typeParam S - The full state union type.\n@typeParam K - The tag to narrow to.\n@param state - The current state.\n@param tag - The tag to check for.\n@returns The narrowed state or undefined.",
  },
];
