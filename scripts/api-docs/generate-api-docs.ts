import { Application, ReflectionKind, DeclarationReflection } from "typedoc";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { createStore, matchEither, tryCatchAsync } from "tagix";
import { GeneratorState } from "./states.ts";
import { Actions } from "./actions.ts";
import { GENERATOR_STORE_NAME } from "./constants.ts";
import { GeneratorError } from "./errors.ts";
import { extractDescriptionAndTags, deduplicateDocs } from "./utils.ts";
import type { ApiItem } from "./types.ts";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const kindMap: Partial<Record<ReflectionKind, string>> = {
  [ReflectionKind.Class]: "class",
  [ReflectionKind.Interface]: "interface",
  [ReflectionKind.Function]: "function",
  [ReflectionKind.Variable]: "const",
  [ReflectionKind.TypeAlias]: "type",
  [ReflectionKind.Enum]: "enum",
};

const store = createStore(GeneratorState.Idle({}), GeneratorState, { name: GENERATOR_STORE_NAME });
store.registerGroup(Actions);

async function run() {
  console.log("Starting API documentation generation (Tagix Store Powered)...");

  store.subscribe((state) => {
    GeneratorState.$match(state, {
      Idle: () => {},

      Bootstrapping: async () => {
        const result = await tryCatchAsync(
          async () =>
            Application.bootstrapWithPlugins({
              entryPoints: ["node_modules/tagix/src"],
              entryPointStrategy: "expand",
              tsconfig: "scripts/api-docs/tsconfig.docs.json",
              skipErrorChecking: true,
              treatValidationWarningsAsErrors: false,
            }),
          (cause) =>
            new GeneratorError({
              message: cause instanceof Error ? cause.message : "Unknown error",
              cause,
            })
        );

        matchEither(result, {
          onRight: (app) => store.dispatch(Actions.bootstrapSuccess, { app }),
          onLeft: (error) =>
            store.dispatch(Actions.fail, { error: `Bootstrap failed: ${error.message}` }),
        });
      },

      Converting: async ({ app }) => {
        const result = await tryCatchAsync(
          async () => {
            const project = await app.convert();
            if (!project) {
              throw new GeneratorError({ message: "Conversion returned null project" });
            }
            return project;
          },
          (cause) =>
            new GeneratorError({
              message: cause instanceof Error ? cause.message : "Unknown error",
              cause,
            })
        );

        matchEither(result, {
          onRight: (project) => store.dispatch(Actions.convertSuccess, { project }),
          onLeft: (error) =>
            store.dispatch(Actions.fail, { error: `Conversion failed: ${error.message}` }),
        });
      },

      Processing: ({ project }) => {
        const reflections = project.getReflectionsByKind(
          ReflectionKind.Class |
            ReflectionKind.Interface |
            ReflectionKind.Function |
            ReflectionKind.Variable |
            ReflectionKind.TypeAlias |
            ReflectionKind.Enum
        ) as DeclarationReflection[];

        const apiDocs = reflections
          .filter((ref) => ref.name && !ref.name.startsWith("_") && !ref.name.includes("$"))
          .map((ref) => {
            const kindStr = kindMap[ref.kind] ?? "unknown";
            if (kindStr === "unknown") return null;

            const { summary, tags } = extractDescriptionAndTags(ref);
            const description =
              tags.length > 0 ? (summary ? `${summary}\n\n` : "") + tags.join("\n\n") : summary;

            return { name: ref.name, kind: kindStr, description: description.trim() };
          })
          .filter((doc): doc is ApiItem => doc !== null);

        const items = deduplicateDocs(apiDocs);
        store.dispatch(Actions.processSuccess, { items });
      },

      Writing: async ({ items }) => {
        const result = await tryCatchAsync(
          async () => {
            const content = `// Auto-generated by scripts/api-docs/generate-api-docs.ts â€” ${new Date().toLocaleString("en-US", { timeZone: "America/Puerto_Rico" })}
export interface ApiItem {
  name: string;
  kind: string;
  description: string;
}

export const API_DOCS: ApiItem[] = ${JSON.stringify(items, null, 2)};
`;
            const outputPath = path.resolve(__dirname, "../../src/content/api_data.ts");
            fs.writeFileSync(outputPath, content, "utf-8");
          },
          (cause) =>
            new GeneratorError({
              message: cause instanceof Error ? cause.message : "Unknown error",
              cause,
            })
        );

        matchEither(result, {
          onRight: () => store.dispatch(Actions.finish, { count: items.length }),
          onLeft: (error) =>
            store.dispatch(Actions.fail, { error: `Write failed: ${error.message}` }),
        });
      },

      Success: ({ count }) => {
        console.log(`Generated ${count} documented items successfully!`);
        process.exit(0);
      },

      Failure: ({ error }) => {
        console.error(`Error: ${error}`);
        process.exit(1);
      },
    });
  });

  store.dispatch(Actions.start);
}

run().catch(console.error);
